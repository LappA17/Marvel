import { useState, useCallback } from "react";

export const useHttp = () => {
    const [loading, setLoading] = useState(false)
    const [error, setError] = useState(null)

    /*Теперь когда у нас есть эти два состояние, нам необходимо будет их как-то менять. Это будет происходить во время запроса,
потому что загрузка у нас идет во время запроса и потом ошибка выскакивает когда-то запрос завершился ошибкой и потом загрузка у нас
выключается когда мы получили ответ. По-этому логично что в этом Хуке у нас должен происходить запрос  */
/* Воспользуемся Хуком useCallback потому что мы можем предположить что в будущем эту функцию нашего
запроса(request) мы будем помещать во внутрь нашего приложение. В том числе она может передаваться во внутрь дочерних Компонентов. И
что бы сразу не вызывать лишних запросов в некоторых вариантах - я буду сразу здесь использовать мемоизированный вариант при помощи
useCallback. 
    Дальше мы создаем функцию и предпологаем что она будет ассинхроная так как у нас будут запросы.
    Наша функция будет принимать url - куда мы будем посылать запрос
    Method - который у нас стоит по умолчанию GET(по умолчанию это если ничего не указано то подставляется наше значение */
    const request = useCallback(async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => {

        //Теперь мы помнич что перед тем как отправить запрос мы должны поставить загрузку в true 
        setLoading(true)/*Если мы сейчас зайдем в CharList и найдем метод onCharListLoading то мы увидим что мы его так же устанавливали
в методе onRequest в этот параметр. И уже потом делали запрос */

        /*После того как установили загрузку - мы будем отправлять fetch на сервер. Но здесь нам нужно подумать как нам обрабатывать ошибку,
ведь он будет только отправлять запрос на сервер, но не будет обрабатывать с помощью then catch finally. По-этому try{} catch{} */
        try{
            const response = await fetch(url, {method, body, headers}) /*Теперь мы отправили запрос и ответ у нас будет помещаться в
response - а это в свою очередь промис и мы получаем конкретные данные(data) */

            /*Теперь нужно проверить наш response */
            if (!response.ok) {
                throw new Error(`Could not fetch ${url}, status: ${response.status}`);
            }
            //те данные что мы получаем в response
            const data = await response.json();

    /* Теперь мы можем сказать что если у нас данные загрузились, те до этого участка дошел код. То мы завершаем загрузку */
            setLoading(false)
            
            return data // и если все впорядке то нам эта функция вернет данные полученные от сервера

            /*Нужно понимать что это не те данные которые нам приходят в МарвелСервис, потому что те данные мы еще и
трансформировали, а это данные от чистого АПИ */
            
        } catch(e) {
            setLoading(false) // когда ошибка пришла то нужно выключить загрузку
            setError(e.message) /*таким образом у нас в стейте error вместо null появится ошибка, ее текст */
            throw e // у нас в аргументе e - уже ошибка которая прийдет нам из браузера
        }
    }, []) 

    /* Если в catch мы просто устанавливаем ошибку, то здесь мы будем чистить. То-есть у нас нет обратного функционала,
нам нужно что бы после setError(e.message) обратно поставить его в null наш стейт error. 
    Это нужно потому что если мы попадем на несуществующего персонажа 404, то после того как мы нажмем try it мы его
не сможем переключить */
    const clearError = useCallback(() => setError(null), []) //тоже на всякий случай поместим сюда useCallback

    //Так как это наш кастомный Хук то мы можем вернуть в виде объекта
    return {loading, request, error, clearError}
} 
/* Теперь займем передачей нашего новосозданного Хука в МарвелСервис(который отправляет запроса на определенные адреса
и уже трансформирает данные). И зачем нам в МарвелСервисе хранить метод getResource если у нас это уже есть в Хуке
    Но при этом мы не будем менять название, потому что getResource - это уже не базовая операция а специализированная,
которая настроена на работу с определенным API и с нужными нам опперациями. 
    Наш хук http - это такая базовая вещь, которая можем использоваться где угодно с чем угодно, а Сервис
это такая специализрованная вещь, которая направленна на работу с Марвел АПИ
      */