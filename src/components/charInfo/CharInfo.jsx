import { useState, useEffect } from 'react';
import PropTypes from 'prop-types';

import useMarvelService from '../../services/MarvelService';

import setContent from '../../utils/setContent'
/* import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';
import Skeleton from '../skeleton/Skeleton'; 
    Теперь нам Спинер, ЕррорМеседж и Скелетон не нужны, потому теперь мы из разных Компонентов, которые будут использовать
тоже эти состояния можем везде удалять эти импорты, потому что они у нас будут в файле setContent*/

import './charInfo.scss';

const CharInfo = (props) => {

    const [char, setChar] = useState(null);

    // Импортируем сюда process и setProcess(для решения проблемы с асинхроынм кодом)
    const {loading, //не используется
           error, // не используется
           process,
           setProcess, 
           getCharacter, 
           clearError} = useMarvelService();

    useEffect(() => {
        updateChar()
    }, [props.charId])

    const updateChar = () => {
        const {charId} = props;
        if (!charId) {
            return;
        }

        clearError();
        getCharacter(charId)
            .then(onCharLoaded)
            .then(() => setProcess('confirmed'))
    }

    const onCharLoaded = (char) => {
        setChar(char);
    }

/* Сначала определим проблему которуя нам нужно решить. 
    В Компонент charInfo здесь у нас есть 4 страшные строки
    Здесь мы взависмио от состояния рендерим разный интерфейс
    Если бы у нас было условие только на Спиннер и Ошибку, то проблемы бы не было
    Но у нас так же проверка на скелетон и контент, если мы посмотрим в контент внимательно то увидим что у нас здесь
!(loading  error  !char), то-есть в суме со всеи проверками аж 8 разных состояний ! тру-фолс, тру-фолс и тд
    У нас идет комбинация, к примеру если лоудинг фиксированое , то еррор и чар могут меняться в итоге у нас здесь
8 разных вариантов в итоге где мы рендерим наш Компонент <View char={char}/>
    Эти состояние разростаются и если мы в условие добавим еще одно состояние то будет 16 возможных состояний из которых
нам необходимо получить только одно общее при котором у нас будет рендериться Компонент View !  
    Представим себе кнопку, у нее может быть много разных состояний: скрыта, показанна, нажата. Мы же не будем
прописывать много разных состояний для кнопки

    И здесь мы поговорим о Принципе Конечного Автомата - это такая сущность, которая имеет определенное количество сотояний
    Конечный Автомат может содержать одно активное состояние(если кнопка скрыта - она не может быть выключенна)
    И для того что бы нам что-то с этой кнопкой сделать, нам нужно поменять её состояние
    
Пример на Курьере:
        1) Ожидание
        2) Получение заказа
        3) Доставка
        4) Получение оплаты
    У нас ОДНО СОСТОЯНИЕ ПЕРЕХОДИТ В ДРУГОЕ
    Сначала курьер ждет, потом получает заказ, потом доставка
    Так же само и с кнопкой, сначала она скрыта, потом показана, потом нажата 
    
    Конечный автомат применяется в очень многих сферах: в искственном интелекте, в играх, в самых разных сферах. 
    Конечный автомат - это математическая модель
    
    FSM(finite-state-machine) - по англ 
    
    Здесь можно вспомнить useReducer и его dispatch - там у нас тоже было много состояний и взависимости от того какое
нам нужно было поменять - мы меняли

    State машины может реализовываться по разному, код и подход к нему тоже может быть разный - это КОНЦЕПЦИЯ А НЕ 
КОНКРЕТНЫЙ ПРИЕМ ИЛИ ТЕХНИКА. Главное что бы соблюдались базовые принципы - это конечное кство состояний, механизм 
перехода от одного сотояние к другому, удобный фционал отображения и только одно АКТИВНОЕ состояние

    Теперь займемся нашим Компонентом
    У него все нормально, кроме удобного фционала отображения, така как ниже фция не особо хорошо читается
    У нас 4 состояние в этом Компоненте: 
        1) Ожидания без каких либо данныз пока пользователь не кликнет на какого-то персонажа
        2) Загрузка
        3) Наличие данных
        4) Ошибка
    Всю логику можно было бы написать здесь, но у нас есть у других Компонентов такая логика , которые что-то грузят
с сервера. 
    Заходим в файлик с нашим Хуком  
    
    После того как мы импортироввали наш process мы создаем фцию setContent
    process - аргумент процесса на который мы будем ориентироваться
    <View char={char}/> - нам нужно будет данные передавать вот сюда {char}, те это будет какой-то персонаж, по-этому
аргумент мы так же и назовем char. Мы будем персонажа передовать если он будет нужен
    Теперь мы будем отталковатсья от какого-то process и в зависимости от него формировать разные кусочки интерфейса
    
    Теперь когда прописали абсолютно все case аж до default
    У нас такой код работать НЕ БУДЕТ ИЗ-ЗА АСИНХРОНОСТИ НАШИХ ОППЕРАЦИЙ
    Мы заходим в httpHook на конкретно строчку setProcess('confirmed') - здесь мы устанавливаем что данные получены
    Но у нас даннеые эксопритруются через ключевое слово return 
    Эти данные у нас попадают в Сервис при получение всех наших персонажей(у нам там был request и мы эти данные
получаем в переменную res. А потом эти данные у нас идут в обработку при помощи фции transformCharacter). Но это
уже дальше действия пошли, при этом мы уже сказали что у нас есть этот Процесс(confirmed) 
    По-этому в нашем Компоненте Реакт будет пытаться отрендерить вот эту часть <View char={char}/> с теми данными
которых еще не существует. Эти данные нам вернуться чуть-чуть попозже, когда они трансформируются при помощи всего
того кода что в MarvelService 
    Если бы у нас были синхронные операции, то проблем бы не было, но здесь у нас асихронный код
    
    Решение - это передать функцию по ручному изменению состояния в сам Компонент
    Мы переходим в наш Хук и ПЕРЕДАЁМ ДАЛЬШЕ НАШУ ФУНКЦИЮ setProcess (те экспортируем её), для того что бы по надобности
наш какой-то Компонент вручную изменял этот процесс
    Теперь нам нужно вызвать setProcess в нужном месте - когда элемент сформировался 
    Это происходит когда данные уже загруженны и они уже переданны в текущий стейт:
    getCharacter(charId) .then(onCharLoaded) ВОТ ЭТО МЕСТО. Мы сначало делаем запросс и потом вызываем фцию onCharLoaded
которая установит состояние setChar
    И так как там используется promise, то мы создадим цепочку и скажем что только тогда, когда данные уже установятся
в наш стейт - мы скажем что в Компоненте действительно все нормально .then(() => setProcess('confirmed'))
    А В НАШЕМ ХУКЕ УДАЛЯЕМ !!! 
    И теперь мы в ручную устанавливаем этот процесс только тогда когда нам действительно это нужно

    Закомментируем полностью весь код который был раньше где переменная скелктон, ерроМеседж и тд
    Так же закомментируем верстку
    Посдтавляем функцию setContent и передаем в него два аргумента
    Теперь когда у нас код дойдет до Ретёрна, он софрмирует блок и запустит фцию по формированию Контента 
    посмотрит какой процесс в текущем состояние у нас внутри Компонента
    и передаст туда состояние нашего персонажа
    и взаивсимости от процесса будет рендериться разные элементы интерфейса с помощью switch case

    Заходим на страницу и всё работает
    Теперь мы можем сделать два вывода: 
    1) что у нас нет сложных условий с изображением Контента(код стал короче и понятней)
    2) нам теперь не нужны такие переменные как error и laoding - у нас за всё отвечает переменная process - которая
отвечает за процесс нашего Компонента

    Тут теперь можем спросить а что делать с фцией setContent - ведь теперь ее прийдется повторять каждый раз в 
разных Компонентах. Обычно стараются писать код в одном похожем стиле, что бы такая фукнция как setContent подходила
для каждого отдельного Компоннета или максимум немного была видоизмененна. 
    По-этому мы просто вынесем ее в отдельную папку utils !
    
    Ниже setContent нам не нужен так как мы уже поместили его в отдельную папку ! 
  */

    /* const setContent = (process, char) => {
        switch(process) {
            case 'waiting':
                return <Skeleton/>;
                break;
            case 'loading':
                return <Spinner/>;
                break;
            case 'confirmed':
                return <View char={char}/>; //это уже момент когда данные полученные и мы рендерим сам Контент
                break;
            case 'error':
                return <ErrorMessage/>
                break;
            default: 
                throw new Error('Unexpected process state');
        }
    } */

    /* const skeleton = char || loading || error ? null : <Skeleton/>;
    const errorMessage = error ? <ErrorMessage/> : null;
    const spinner = loading ? <Spinner/> : null;
    const content = !(loading || error || !char) ? <View char={char}/> : null; */

    // после того как мы импортировали setContent - эта фция будет у нас использоваться вот здесь
    // так же передаем как второй аргумент наш Компонент View
    return (
        <div className="char__info">
            {/* {skeleton}
            {errorMessage}
            {spinner}
            {content} */}
            {setContent(process, View, char)}
        </div>
    )
}

// Здесь теперь как Проперти передаём уже не char, а data
/* const View = ({char}) => {
    const {name, description, thumbnail, homepage, wiki, comics} = char; */
   const View = ({data}) => {
        const {name, description, thumbnail, homepage, wiki, comics} = data;

    let imgStyle = {'objectFit' : 'cover'};
    if (thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
        imgStyle = {'objectFit' : 'contain'};
    }

    return (
        <>
            <div className="char__basics">
                <img src={thumbnail} alt={name} style={imgStyle}/>
                <div>
                    <div className="char__info-name">{name}</div>
                    <div className="char__btns">
                        <a href={homepage} className="button button__main">
                            <div className="inner">homepage</div>
                        </a>
                        <a href={wiki} className="button button__secondary">
                            <div className="inner">Wiki</div>
                        </a>
                    </div>
                </div>
            </div>
            <div className="char__descr">
                {description}
            </div>
            <div className="char__comics">Comics:</div>
            <ul className="char__comics-list">
                {comics.length > 0 ? null : 'There is no comics with this character'}
                {
                    comics.map((item, i) => {
                        // eslint-disable-next-line
                        if (i > 9) return;
                        return (
                            <li key={i} className="char__comics-item">
                                {item.name}
                            </li>
                        )
                    })
                }                
            </ul>
        </>
    )
}

CharInfo.propTypes = {
    charId: PropTypes.number
}

export default CharInfo;