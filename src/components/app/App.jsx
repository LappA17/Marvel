import { Component } from "react";
import AppHeader from "../appHeader/AppHeader";
import RandomChar from "../randomChar/RandomChar";
import CharList from "../charList/CharList";
import CharInfo from "../charInfo/CharInfo";

import decoration from '../../resources/img/vision.png';

/* Ваня вверху импортировал Компонент из Реакта
   App сделал классом,
   Ретёрн поместил в Рендер
   в state у App поместил state = {
       showRandomChar: true
   }
   создал метод toggleRandomChar = () => {
                    this.setState((state) => {
                        return {
                            showRandomChar: !state.showRandomChar
                        }
                    })
                }
    Потом создал кнопку button onClick={this.toggleRandomChar} 
    Таким образом все что делалось выше создавало кнопку для переключение персонажа и после ее нажатия персонаж менялся
    Теперь представим что автоматически персонаж должен меняться каждые 3 секунды
    В компоненте RandomChar вместо this.updateChar(Ваня удалил ее), он поместил setInterval и туда поместил фцию this.updateChar и 3000 
    И что бы убедиться что этот метод действительно срабатываем Ваня будет в console.log в методе onCharLoaded выводить слово update
что бы понимать что фция запустилась и персонаж обновлен
    И ПОСЛЕ КАЖЛОГО СОЗЛАНИЕ НОВОГО ГЕРОЯ(КОМПОНЕНТА) У НАС ВЫХОДИТ В КОНСОЛЬ НЕ ОДИН update А ДВА ! ЧТО БЬЕТ ПО НАШЕЙ ОПТИМИЗАЦИ КОДА
    ТЕПЕРЬ ПОСЛЕ КАЖДОГО НАЖАТИЯ КНОПКИ click me которую мы создали, то у нас вообще начинается хауес и кнопка update пояляется все
больше и больше, те идет создание все больше новых компонентов

ТЕПЕРЬ ОБЪЯСНЕНИЕ: этот Баг - когда компоненты исчезают, но запросы все равно идут связан с тем что мы нигде не используем clearInterval
мы нигде не остановили интервал и наш компонент продолжает работать, даже не смотря на то что мы удалили его полностью со страницы. И 
если так будет происодить постоянно то рано или поздно наше приложение зависнет и ляжет. А вторая приччина - если в ЖС есть ссылка на 
какой-то объект, то он из памяти не исчезает и у нас так как интервал повешан на этот компонент, то у нас каждый раз когда он пересоздается
старый компонент у нас тоже сохраняется в памяти, на него есть ссылка, на нем еще тоже работает интервал и это тоже бьет по оптимизации
и это все называется УТЕЧКОЙ ПАМЯТИ !!!

    У Компонента Реакта есть ТРИ этапа :
1) Наш Компонент появляется на странице
2) Компонент может обновляться двомя способами:  Если компонент у нас получает новое свойство, то он перерисовывается и таким образом
обновляется и если внутри компонента был изменен state - то он тоже обновляется(То-есть или new props или new state)
3) Удаление компонента, как пример когда мы нажимаем на кнопку НАШ СТАРЫЙ КОМПОНЕНТ ИСЧЕЗАЕТ И ПОЯВЛЯЕТСЯ НОВЫЙ 
4) Ваня сказал что еще можно сюда отнести ошибку в компоненте !
    Это и есть жизненный цикл компонента и на каждый из таких этапов мы можем вызвать определенные функци(Хуки Жизненного Цикла)
1)componentDidMount() - когда только появился
2)componentDidUpdate() - обновление
3)componentWillUnmount() - удаление
4)componentDidCatch() - ошибка

1)Mount - это монтирование. Те появление компонента, его зарождение. Как только наш Компонент начинает появлятся, то первое что у него
начинает вызываться это CONSTRUCTOR, после этого вызывается Render(там где рендериться верстка те наш интерфейс), дальше Реакт обновляет
ДОМ структуры и обновляет РЕФЫ и после всего этого у нас вызывается Хук componentDidMount
2)Обновление(Update). Тут есть new props, setState() или forceUpdate()(это насильно обновить компонент), то здесь уже не будет constructor
а сразу будет render() с новыми данными, который приходят от сюда new props, setState(), forceUpdate(). ЭТО О ЧЕМ ГОВОРИЛ ВАНЯ ЧТО
setState() КАЖДЫЙ РАЗ ВЫЗЫВАЕТ ВЫЗОВ МЕТОДА render() и Обновление интерфейса ! Потом опять же идет обновление всего ДОМа(все что на странице)
и уже после этого вызывается componentDidUpdate()
3)Размонтирование - когда компонент полностью исчезает со страницы, то componentWillUnmount()

    Ваня сказал что эту табличку нужно выучит и в идале взять console.log() и вставить в каждый из этапов, который у нас будут происходить
В RandomChar:
1) В конструктора вставляем console.log('constructor')
2) В render() методе вставляем console.log('render')
3) Cоздаем метод componentDidMount и mount в консоль
4) Cоздаем метод componentWillUnmount и unmount в консоль
Теперь при перезагрузки страницы у нас идет constructor, render, mount и после клика на кнопку click me появляется unmount
и заново constructor, render, mount

    ТЕПЕРЬ ВОЗВРАЩАЕМСЯ К БАГУ: почему у нас происходит 2 запроса на сервер this.updateChar.
    Потому что мы его оставляли в constructor и происходило так что мы наш запрос отправляли тогда, когда наш запрос 
вообще не был создан. Мы на этапе конструктора делали запрос и мы понимали что нам некуда засунуть эти данные, у нас
возможно и state не был готов и Реакт видя это уже отправлял второй запрос что бы уже аддекватно получить наши данные
для использование в рендере

    В табличке мы понимаем что можно делать на определенных этапах. Нас интересует этап commit - этап когда Реакт может
работать с ДОМ структурой и выполнять ПОБОЧНЫЕ ЭФФЕКТЫ и НАЗНАЧАТЬ ОБНОВЛЕНИЯ. Назначения обновлениея - это то что мы 
сейчас делаем, мы можем это использовать идеально на наших трех основных хуках.
   По-этому componentDidMount - это идеально место для инициализации компонента, что бы вызывать сетевые фции
И мы вырезаем this.updateChar() с конструктора и помещаем в нашу функцию componentDidMount
   Теперь идет constructor, render, mount, update, render. ТЕПЕРЬ update НЕ ПОВТОРЯЕТСЯ. ЛЮБЫЕ ОБНОВЛЕНИЯ, ЗАПРОСЫ К АПИ,
ЗАПРОСЫ К СЕРВЕРАМ НУЖНО ДЕЛАТЬ В componentDidMount А НЕ В КОНСТРУКТОРЕ

    Теперь подставляем в componentDidMount setInterval(this.updateChar, 3000) после нашего this.updateChar(). То есть благодаря
this.updateChar() - мы вызвали первично нашу функцию для обновление нашего компонента(что бы один раз загрузить данные),
а потом каждые 3 секунды эту функцию запускаем

    И ТЕПЕРЬ ОЧЕНЬ ВАЖНО, ГДЕ НАМ ОСТАНАВЛИВАТЬ this.updateChar(), КОНЕЧНО ЖЕ componentWillUnmount - этот хук будет там 
где наш компонент полностью исчезает со страницы и ИНТЕРВАЛ ОСТАНАВЛИВАЕТСЯ.
    ТЕПЕРЬ КАЖДЫЕ 3 СЕКУНДЫ ПОЯВЛЯЕТСЯ update и сразу render, опять update, render
    После нажатие на click me все останавливается и больше не будет ничего, не будет апдейта и рендера. Потом опять называем
click me и по новой начинается update, render
    
    Если я при помощи стандартного ДОМ АПИ назначаю add.eventListener в Реакте, то его нужно потом опять же удалять при помощи
removeEventListener. Если этого я не сделаю то какой-то удаленный элемент будет занимать место в памяти, и это тоже своего
рода утечка памяти

    Теперь конструктор мне абсолютно не нужен !
*/

class App extends Component {
    state = {
        showRandomChar: true
    }

    toggleRandomChar = () => {
        this.setState((state) => {
            return {
                showRandomChar: !state.showRandomChar // переключаем с true на false
            }
        })
    }
/* this.state.showRandomChar ? <RandomChar/> : null - если у стейста будет showRandomChar, то рендерим RandomChar, если нет то налл */
   render () {
    return (
        <div className="app">
            <AppHeader/>
            <main>
                {this.state.showRandomChar ? <RandomChar/> : null}
                <button onClick={this.toggleRandomChar}>Click me</button>
                <RandomChar/>
                <div className="char__content">
                    <CharList/>
                    <CharInfo/>
                </div>
                <img className="bg-decoration" src={decoration} alt="vision"/>
            </main>
        </div>
    )
   }
}

export default App;